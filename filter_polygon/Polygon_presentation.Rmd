---
title: "Filter_Polygon_presentation"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# started by Katja Seltmann, 2020
# Script to map occurrence records of species (lat/long) that occur only within the boundaries of Coal Oil Point Reserve (shp file)
# COPR occurrence records in tab-delimited format: https://ucsb.box.com/s/7xp88xhg1xn7decsv0t3ll8du653deub
# COPR boundary files: https://ucsb.box.com/s/nd1s0e3ted8zsu0ir4wbxu7qpe94ht8o

#The goal of this script is to:
#draw boundary of copr on map
#Trim specimen_data (occurrence.txt) based on copr boundary creating new file that only contains specimens whose coordinates are within that boundary
```{r}
#If you havent installed these packages before, delete the '#' in front of the install.packages("") name and run the code. once this has been loaded make sure to re add the '#' so it isn't installed multiple times when running other code

#install.packages("ggplot2") 
#install.packages("sf") 
#install.packages("raster") 
#install.packages("rgdal") 
#install.packages("dplyr") 
#install.packages("tidyr") 
#install.packages("plotly")  
#install.packages("tmap")
```


```{r}
#required libraries
library(ggplot2) #library for visualization and plotting.
library(sf) #Spatial objects package, very useful for vector data types
library(raster) #Spatial object package for raster type data
library(rgdal) #Spatial objects
library(dplyr) #Cleaning and data wrangling 
library(tidyr) #Very large package for data organization
library(plotly) #Makes ggplots interactive 
library(tmap) #Another interactive map package
library(ggmap)
library(tidyverse)
```

## Bringing in the data & cleaning
```{r}
#file that contains over 75K of specimen data with lat/long coordinates
specimen_data <- read.delim(file="occurrence.txt",header=TRUE)

#NOTE: If this returns Error in file(file, “rt”) : cannot open the connection, then most likely this is a path issue specific to your computer. First try changing the code to: specimen_data <- read.delim(file ="filter_polygon/occurrence.txt",header=TRUE)
```

```{r}
#remove rows where order, lat/long do not exist
specimen_data <- subset(specimen_data, !is.na(order) & !is.na(decimalLongitude) & !is.na(decimalLatitude))
```

```{r}
#read boundary from shp file
copr_boundary_2020 <- st_read("COPR_Boundary_2010/COPR_boundary2010.shp") #Vector type.

#NOTE: If this is unable to be read it may again be a path issue, try: copr_boundary_2020 <- st_read("filter_polygon/COPR_Boundary_2010/COPR_boundary2010.shp")

#What is the projection of copr_boundary_2020

#Global datum is NAD83. California zone 5 is code: ESPG:2229.

#A great site for looking up crs info: https://spatialreference.org/ 
```

## What is the CRS of our occurence data?
```{r}
crs(copr_boundary_2020)
crs(specimen_data) #NA so it hasnt been assigned a crs.

```
```{r}
#Another method for storing crs's is to place them in a data column. Lets look at the names of the data columns. 
names(specimen_data)

#There are some here that look like they could be right, however if you filter them out you will find that they do not yield a crs. 

#While looking at these some important column names are 134 and 133 which contain decimal latitude and decimal longitude, as well as column 194 that contains taxonomic Order of the specimen found.  


```
## Lets filter out the data so that we have only those 3 columns of interest (lat, long, and order)
```{r}
specimen_data_order <- specimen_data[c(134, 133, 194)]
```

##Lets plot the boundary vector data just to take a look at it
```{r}
#draw boundary from shp file
ggplot() +
  geom_sf(data = copr_boundary_2020, fill = "palegreen", color = "black")
```
## Will these two data sets we have plot together?
```{r}
ggplot() +
  geom_sf(data = copr_boundary_2020, fill = "palegreen", color = "black") +
  geom_point(data = specimen_data_order, aes(x = decimalLongitude, y = decimalLatitude), shape = 1)

#No they will not plot together since they have different CRSs 

```
##Lets try assigning a CRS to our occurence data and then transform it into the boundary files CRS. 
```{r}
#Technically the ESPG:4269 (NAD83) and ESPG:4326 (WGS84) are not equivalent, for most applications they can treated as equivalent. 

#First lets change the txt. data into a sf object that uses the standard crs = 4326 for latlong. 

occur_sf_order <- st_as_sf(specimen_data_order, coords = c('decimalLongitude', 'decimalLatitude'), crs = 4326)

extent(occur_sf_order)
extent(copr_boundary_2020)
#Now lets transform this new sf object to the crs using our boundary data 

occur_sf_order_new <- st_transform(occur_sf_order, 
                             st_crs(copr_boundary_2020))
#Check the extents, they appear to be in the same range 
extent(occur_sf_order_new)

extent(copr_boundary_2020)
```
## Now lets graph 
```{r}
ggplot() +
  geom_sf(data = copr_boundary_2020, fill = "palegreen", color = "black") +
  geom_sf(occur_sf_order_new, mapping = aes(geometry = geometry), size = 1) +
  ggtitle("Occurence of Plant Specimens at Coal Oil Point")
#Okay, it seems that the data is including lots of points that are outside the specified range of the boundary shape
```
## Lets subset the data to only include whats inside our vector shp file. 
```{r}
occur_sf_order_new_subset <- occur_sf_order_new[copr_boundary_2020,]
```

## And graph again
```{r}
ggplot() +
  geom_sf(data = copr_boundary_2020, fill = "palegreen", color = "black") +
  geom_sf(data_hymenpotera, mapping = aes(geometry = geometry), size = 1) +
  ggtitle("Occurence of Plant Specimens within Coal Oil Point")

#And thats what we want! 
```

## If we wanted to now take this newly subsetted data of whats inside the preserve and make a .csv file out of it 
```{r}
##Export as a csv file

directory <- getwd()
directory

#write.csv(occur_sf_order_new_subset, "C:/Users/JTroo/Desktop/Github/occurence_maps/occurrence-maps/filter_polygon/occur.csv", row.names = TRUE)
 #So this is the exported dataframe for just taxonomy and geo coordinates. 


#This is a new way to format the writing our .csv file. Importantly it maintains the geometry column and keeps the other columns for being messed up. 
st_write(occurence_order_subset_sep_unique, "C:/Users/jtmil/OneDrive/Desktop/CCBER/occurrence-maps/filter_polygon/occur5.csv",  layer_options = "GEOMETRY=AS_WKT")


x <- st_read("occur5.csv", options = "GEOM_POSSIBLE_NAMES=WKT")
x
crs(x)
crs(occur_sf_order_new_subset)

x_w_crs <- st_set_crs(x, "+proj=lcc +lat_0=33.5 +lon_0=-118 +lat_1=35.4666666666667
+lat_2=34.0333333333333 +x_0=2000000.0001016 +y_0=500000.0001016
+datum=NAD83 +units=us-ft +no_defs")
#occurence_order_subset_sep_unique
```
# If we want to visualize our data in other unique ways 

## Lets try making a nicer graph that shows taxonomic order in relation to the data points
```{r}
#Now lets graph by order.  

Order_Plot <- ggplot() +
                geom_sf(data = copr_boundary_2020, fill = "grey", color = "black") +
                geom_sf(occur_sf_order_new_subset, mapping = aes(geometry = geometry, color = order,)) +
                ggtitle("Distribution of identified organisms within Coal Oil Point") +
                labs( x = "Longitude", y = "Latitude") +
                theme_gray() +
                theme(legend.key.size = unit(0.5, "cm"), 
                axis.text = element_text(size = 7), 
                )

Order_Plot #While this is more informative, its rather hard to read
```
## Lets try making an interactive plotly map so its easier to interpret
```{r}
#Making an interactive map, where when you hover over each data point you may see the Taxonomic Order of the observed specimen. 
ggplotly(Order_Plot) #This is alot better, however notice that theres 1603 observations...but not that many points on the graph. 


```
## Lets figure out a way to make it where we can get counts for each unique order with the same gps coordinate location so that we can see how many reaccurances appear in a location. 
```{r}
#Seems we need to seperate out the geometry column into new columns 

occurence_order_subset_sep <- occur_sf_order_new_subset %>%
  dplyr::mutate(lat = sf::st_coordinates(.)[,2],
                lon = sf::st_coordinates(.)[,1])
occurence_order_subset_sep
```

```{r}
#This is the correct way to sum up counts of the observations per coordinate point
occurence_order_subset_sep_unique <- occurence_order_subset_sep %>% 
  dplyr::group_by(lat, lon) %>% #Designate unique lat lon
  dplyr::mutate(count = n()) #Create a new column with the counts 
```

## Lets graph with both ggplot and ggplotly to see if the counts appear next to the data points. 
```{r}
#Now lets graph by order.  

Order_Plot_counts <- ggplot() +
                geom_sf(data = copr_boundary_2020, fill = "grey", color = "black") +
                geom_sf(occurence_order_subset_sep_unique, mapping = aes(lon, lat,color = order, count = count)) +
                ggtitle("Distribution of identified organisms within Coal Oil Point") +
                labs( x = "Longitude", y = "Latitude") +
                theme_gray() +
                theme(legend.key.size = unit(0.5, "cm"), 
                axis.text = element_text(size = 7), 
                )

ggplotly(Order_Plot_counts, tooltip = c("order", "count"))

rainbow(17)
```

## Lets now try creating a heatmap of the data showing higher densities where the higher counts exist.
```{r}
#First lets create a subset of data that only looks at a specific order, Since hymenpotera has good representation and is a group of interest lets use that.
data_hymenpotera <-occurence_order_subset_sep_unique %>% 
  dplyr::filter(order == "Hymenoptera")
```

## Basemap for barebones structure
```{r}
tmap_mode("plot")
#tmap_mode("view")
tm_shape(copr_boundary_2020) +
  tm_borders() +
  tm_compass(position = c("left", "top")) +
  tm_layout(main.title = "Coal Oil Point Reserve")
#Basic map

```

```{r}
tmap_mode("view")
#tmap_mode("plot")
tm_shape(copr_boundary_2020) +
  tm_borders() +
   tm_graticules() +
  tm_shape(data_hymenpotera) + tm_bubbles(size = "count", col = "red") +
   tm_compass(position = c("left", "top")) +
 
  
  tm_layout(main.title = "Coal Oil Point Reserve Hymenpotera Observations")
```
```{r}
#Lets organize all of them into seperate data sets while we're at it. 
data_amphipoda <- occurence_order_subset_sep_unique %>% 
  dplyr::filter(order == "Amphipoda")

data_araneae <- occurence_order_subset_sep_unique %>% 
  dplyr::filter(order == "Araneae")

data_archaeognatha <- occurence_order_subset_sep_unique %>% 
  dplyr::filter(order == "Archaeognatha")

data_coleoptera <- occurence_order_subset_sep_unique %>% 
  dplyr::filter(order == "Coleoptera")

data_decapoda <- occurence_order_subset_sep_unique %>% 
  dplyr::filter(order == "Decapoda")

data_dermaptera <- occurence_order_subset_sep_unique %>% 
  dplyr::filter(order == "Dermaptera")

data_diptera <- occurence_order_subset_sep_unique %>% 
  dplyr::filter(order == "Diptera")

data_ephemeroptera <- occurence_order_subset_sep_unique %>% 
  dplyr::filter(order == "Ephemeroptera")

data_hemiptera <- occurence_order_subset_sep_unique %>% 
  dplyr::filter(order == "Hemiptera")

data_isopoda <- occurence_order_subset_sep_unique %>% 
  dplyr::filter(order == "Isopoda")

data_lepidoptera <- occurence_order_subset_sep_unique %>% 
  dplyr::filter(order == "Lepidoptera")

data_odonata <- occurence_order_subset_sep_unique %>% 
  dplyr::filter(order == "Odonata")

data_orthoptera <- occurence_order_subset_sep_unique %>% 
  dplyr::filter(order == "Orthoptera")

data_pedunculata <- occurence_order_subset_sep_unique %>% 
  dplyr::filter(order == "Pedunculata")

data_psocodea <- occurence_order_subset_sep_unique %>% 
  dplyr::filter(order == "Psocodea")

data_sessilia <- occurence_order_subset_sep_unique %>% 
  dplyr::filter(order == "Sessilia")

```

```{r}
tmap_mode("view")
#tmap_mode("plot")
tm_shape(copr_boundary_2020) +
  tm_borders() +
   tm_graticules() +
  tm_shape(data_hymenpotera) + tm_bubbles(size = "count", col = "red") +
  tm_shape(data_decapoda) + tm_bubbles(size = "count", col = "blue") +
   tm_compass(position = c("left", "top")) +
 
  
  tm_layout(main.title = "Coal Oil Point Reserve Hymenpotera Observations")
```

```{r}
occurrence_filtered <- read.csv("occur2.csv")

copr_boundary <- st_read("COPR_Boundary_2010/COPR_boundary2010.shp")

#Lets organize all of them into seperate data sets while we're at it. 


test<- occurrence_filtered %>% filter(order == "Hymenoptera"
                                      )
```

```{r}
library(leaflet)
library(leaflet.extras)
library(maps)

copr <- readOGR(dsn = "COPR_Boundary_2010/COPR_boundary2010.shp")

leaflet() %>% addTiles(copr)
```
```{r}
filter(occurrence_filtered %>% order) %>% 
           groupby(order, geometry)
```
```{r}

```
## Creating a subsetting function for the taxonomic rank
```{r}
filter_taxa <- function(data, kingdom = NULL, phylum = NULL, class = NULL, order = NULL, family = NULL, genus = NULL, species = NULL) { #create a function
  if(!is.null(kingdom)){
    kingdom_output <- data[data$kingdom %in% kingdom,]
  }
  if(!is.null(phylum)){
    phylum_output <- data[data$phylum %in% phylum,]
  }
  if(!is.null(class)){
    class_output <- data[data$class %in% class,]
  }
  if(!is.null(order)){
    order_output <- data[data$order %in% order,]
  }
  if(!is.null(family)){
    family_output <- data[data$family %in% order,]
  }
  if(!is.null(genus)){
    genus_output <- data[data$genus %in% genus,]
  }
  if(!is.null(species)){
    species_output <- data[data$species %in% species,]
  }
  #data_compiled <- data(kingdom_output, phylum_output, class_output, order_output, family_output, genus_output, species_output)
  #df <- as.data.frame(data_compiled)
  
  return(as.data.frame(c(kingdom_output, phylum_output, class_output, order_output, family_output, genus_output, species_output )))
}

test_taxa_filter <- filter_taxa(specimen_data, kingdom = "Animalia", phylum = "Arthropoda", class = "Insecta", order = "Hymenoptera", family = "Halictidae",  genus = "Augochlorella", species = "Augochlorella pomoniella" )

```

